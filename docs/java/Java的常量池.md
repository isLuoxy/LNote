# Java的常量池

##1、静态常量池

通常是指 **类常量池**，即`*.class`文件中的常量池，编译的时候被存入了类，方法的信息和字符串等，占用`Class`文件空间最大的数据项目之一。主要有两大类常量：**字面量**和**符号引用**

- 字面量：如文本字符串、声明为`final`的常量值等
- 符号引用：
  - 类和接口的全限定名
  - 字段的名称和描述符
  - 方法的名称和描述符

##2、动态常量池

通常是指 **运行时常量池** ，当`class文件`被加载进内存后，由**类常量池**转化而来。



## 3、关于String的intern方法

jdk1.7之前和之后是有区别的。

~~~java
String a = "A";
String aa = new String("A");
String temp = aa.intern();

System.out.println(a == temp);
System.out.println(aa == temp);
~~~

这里输出是多少呢？我们分别在jdk1.7之前和jdk1.7之后进行讨论

~~~java
// 在 jdk1.7 之前

/*
 * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以
 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。
 */
String a = "A";

/*
 * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于
 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中）
 * 
 */
String aa = new String("A");

/*
 * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字
 * 符串“A”的地址值
 */
String temp = aa.intern();

System.out.println(a == temp); // true
System.out.println(aa == temp); // false
~~~

~~~java
// 在 jdk1.7 之后

/*
 * 首先查找字符串常量池是否存在"A"字符，因为是第一次创建，所以字符串常量池中是不存在字符“A”的，所以
 * 这个时候会在字符串常量池创建一个“A”字符，并把这个字符的地址赋给引用a。
 */
String a = "A";

/*
 * 在执行这个语句的时候，同样会先去字符串常量池查找是否存在，如果存在那么直接将该字符串对象“A”（位于
 * 量池中）去初始化堆中的对象，然后将堆中的对象（由new String生成）的地址赋给引用aa（位于栈中）
 * 
 */
String aa = new String("A");

/*
 * 因为aa的对象在堆中的内容为字符串“A”，在字符串常量池中也存在相同的对象内容，所以直接返回常量池中字
 * 符串“A”的地址值
 */
String temp = aa.intern();

System.out.println(a == temp); // true
System.out.println(aa == temp); // false
~~~

在这里两个版本的结果都是一样的，是因为**常量池中的元素是已经存在的**了，所以不同jdk的`intern()`方法都是直接返回字符串的地址，接下来展示一下如果常量池中的元素不存在，那么就可以看到不同jdk的`intern（）`带来的结果是不同的。

下面贴出示例代码：

 ~~~java
String aa = new String("A")+new String("A");
String temp = aa.intern();
String a = "AA";

System.out.println(a == temp);
System.out.println(aa == temp);
 ~~~

~~~java
// 在 jdk1.7 之前

/*
 * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中）
 * 2、此时的常量池只有“A”字符串对象。
 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。
 */
String aa = new String("A")+new String("A");

/*
 * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA”
 * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之前的版本中，
 * 会将堆中对象的字符串拷贝一份过去，然后返回该字符串的地址值。（我的理解是 常量池添加“AA”这个字符串对
 * 象，然后返回改地址值，类似String x = "AA")
 */
String temp = aa.intern();

/*
 * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a
 */
String a = "AA";

System.out.println(a == temp); // true
System.out.println(aa == temp); // false
~~~

~~~java
// 在 jdk 1.7 之后

/*
 * 1、创建了4个对象，2个堆对象+1个合并后的堆对象+1个字符串"A"对象（在常量池中）
 * 2、此时的常量池只有“A”字符串对象（此处在常量池中不会生成字符串AA对象，而只有一个字符串A对象）。
 * 3、引用aa指向的堆地址为合并后的对象，内容为“AA”。
 */
String aa = new String("A")+new String("A");

/*
 * 1、此时intern（）方法同样会先查找常量池中是否有跟对象一样内容的对象（就是在常量池中查找是否有“AA”
 * 字符串），由第一条代码的分析可知这个时候常量池中只有字符串为“A”的对象，此时在jdk1.7之后的版本中，
 * 不再是将堆对象的字符串拷贝一份过去，而是将堆对象的地址值存储在常量池中，然后返回该地址值。（假如此
 * 时aa指向的地址值为0x1001,那么常量池中表示字符串"AA"对象的地址值也是0x1001)
 * 注：在常量池中并没有实际生成字符串“AA”，而只是生成对堆中字符串为“AA”的对象的引用。（就是一个地
 * 址值，然后可以理解这个地址值就是代表字符串“AA”）
 */
String temp = aa.intern();

/*
 * 由第二条代码的分析可知此时常量池中已经有字符串“AA”对象，所以直接返回地址值给引用a
 */
String a = "AA";

System.out.println(a == temp); // true
System.out.println(aa == temp); // true,这里与之前都不同，是因为常量池中的地址值就是堆对象的地址值，也是 jdk 1.7 后intern()方法的改变
~~~



> String s1=new String("abc");
>
> s1是栈内变量，它的内存保存的是堆中的new String对象的地址，new String在堆中生成对象，并用常量池的字符串对象"abc"初始化堆中的对象，**所以堆中的对象的内存的内容和常量池对象的内存的内容一样，但是是不同的两个对象**





