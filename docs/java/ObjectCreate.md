# 对象的创建过程

>  A a  = new A(); 在创建对象中发生了什么

直接上一段代码

~~~java
public class father{
    // 设置静态代码块
    static{
        System.out.println("我是父类的静态代码块");
    }
    
    // 设置实例变量
    public int money = 100;
    
    // 设置代码块
    ｛
        System.out.println("我是父类的代码块")；
      ｝
}

public class son extends father{
     // 设置静态代码块
    static{
        System.out.println("我是子类的静态代码块");
    }
    
    // 设置实例变量
    public int money = 50;
    
    // 设置代码块
    ｛
        System.out.println("我是子类的代码块")；
      ｝
        
      // 程序入口
       public static void main(String[] args){
        	father f = new son();
    }
}
~~~

运行这个程序看看结果是什么。

1. 首先，在main方法运行前，会先查看main方法所在的类是否已经加载过，如果没有的话，会先加载类。我们都知道在jvm中类的加载经过5个过程：**加载、连接、初始化、使用、卸载**。连接分为**验证、准备、解析**

![](https://i.loli.net/2018/08/08/5b6a535b0d8c4.png)

![](https://i.loli.net/2018/08/08/5b6a534638ff0.png)

可以看出在运行main方法之前，

1）去常量池当中定位类的符号引用；  

2) 检查这个类的符号引用是否被加载，解析和初始化过；

3) 如果没有，则进行类加载的过程。**在加载过程中的连接阶段中，准备阶段会为类变量分配内存，并且赋初值。所以可以通过断点可以看到在main方法运行之前，控制台已经输出了静态代码块中的语句。**

~~~java
public static int value = 30;
// 在准备阶段，会为value分配空间，并且赋初值0，而30要等到初始化阶段才会被赋值
~~~



4) 如果已经加载过，则虚拟机在堆中为对象分配内存；其中对象包括了实例变量，所以在这里也会先在堆中为这里变量分配内存。

5) 虚拟机为分配到的内存空间都赋零值；  

6) 虚拟机对对象进行必要的设置，比如对象是哪个类的实例，对象的哈希码，对象的GC分代年龄等信息； 

7) 执行<init>方法，按照程序意愿初始化对象，即执行类的初始化函数 （Tip：**这里的初始化不是类加载过程的初始化，这里会根据程序意愿为对象的实例变量赋值**）

![](https://i.loli.net/2018/08/08/5b6a522fe5eae.png)

![](https://i.loli.net/2018/08/08/5b6a526e533ff.png)

![1206552-20180509200449094-1895771800](https://i.loli.net/2018/08/08/5b6a526ec1689.png)

![](https://i.loli.net/2018/08/08/5b6a526f8fd0d.png)

![1206552-20180509200556465-1886589764](https://i.loli.net/2018/08/08/5b6a52705ff6d.png)

![1206552-20180509200612117-1222391685](https://i.loli.net/2018/08/08/5b6a5270d9130.png)

​	图片可以轻易看出实例变量初始化的过程

8) 执行完成之后，就得到了一个新的对象。 



如果存在父类，那么父类一定要先于子类存在，我们都知道如果不重写子类的构造方法和父类的构造方法，那么默认情况下子类的构造方法会调用父类的无参构造方法，而此时就会查看父类是否已经加载过了，过程上面已经讲过了，如果父类已经加载过了，那么就会初始化父类的实例变量和代码块，再到父类的构造方法；接下来才是初始化子类的代码块、实例变量，最后是子类的构造方法。

这里讲的过程都是父类和子类已经加载过的了，当然，这些加载过程我们是看不到的，在main方法执行前，你会看到父类的静态代码块会执行，子类的静态代码块也会执行，这个是在类加载过程中就解决的，而不是在运行过程中我们可以依靠断点查看到的。

总的来说，new一个新的对象时

1. 会先查看对象所属的类是否有父类，如果有，会先进行父类的类加载，然后进行子类的类加载。两个都加载完成后，会发现两个类中如果有静态属性（类属性）、静态代码块会被执行，即被初始化（**过程是在类加载的准备和初始化阶段**）。
2. 接下来就会初始化父类的实例变量和代码块，然后是父类的构造方法，通过反编译其实可以看到虚拟机是把代码块和实例变量放在构造方法内部的前面。所以很容易理解先初始化实例变量和代码块，再执行构造方法。（**从jvm的角度上看就是先在堆中为对象分配内存，这里对象包括实例变量，会在堆中也为实例变量分配内存，并且赋初值，然后才根据程序意愿为对象的实例变量赋值**）