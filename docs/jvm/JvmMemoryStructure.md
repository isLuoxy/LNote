# jvm内存结构

![图片来自《深入理解JAVA虚拟机》](https://i.loli.net/2018/11/25/5bfa95024f4fa.png)

## 1、程序计数器

程序计数器是线程私有的，它是一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器。程序计数器不会抛出 OutOfMemoryError 错误。



## 2、虚拟机栈

虚拟机栈是线程私有的，每条线程都有各自的虚拟机栈，而且不能互相访问。当一个方法运行时，线程会在自己的虚拟机栈的栈顶创建栈帧（Stack Frame），用于存储**局部变量表**、**操作数栈、动态链接、方法出口等信息**，当方法运行完后，栈帧会从栈顶出栈，所以方法从调用到执行结束的过程，就对应着一个栈帧在虚拟机栈从入栈到出栈的过程。

平时我们所说的栈存放引用、局部变量等，这里的栈就是指虚拟机栈，或者说是是**虚拟机栈中的局部变量表**

虚拟机栈会抛出两种异常：

① `StackOverflowError` ：当线程请求的栈深度大于虚拟机所允许的深度，那么就会抛出 **StackOverflowError** 错误；

②`OutOfMemoryError` ：如果虚拟机栈动态扩展时无法申请到足够的内存，那么就会抛出 **OutOfMemoryError** 错误



## 3、本地方法栈

与虚拟机栈相似，都是线程私有的，不同的是虚拟机栈执行的是JAVA方法，而本地方法栈执行的是本地（native）方法；本地方法栈也会抛出两种错误。



## 4、堆

堆不是线程私有的，而是线程共享的内存区域。随着虚拟机的启动而创建，目的是存放对象实例。**在虚拟机规范中描述是所有的对象实例和数组都要在堆上分配**。因为是存放对象实例的地方，所以虚拟机的垃圾收集器也是作用在这个区域，因此堆很多时候也被称作 GC堆。

如果在堆中没有内存完成实例分配，并且堆无法再扩展时，将会抛出 OutOfMemoryError 异常。



## 5、方法区

方法区也不是线程私有的，而是线程共享的内存区域。用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器（jit）编译后的代码等数据，虽然JAVA虚拟机规范把方法去描述为堆的一个逻辑部分，但是它却有一个别名”non-heap（非堆）“目的是要跟堆区分开来。

如果在方法区中无法满足内存分配需求时，将会抛出 OutOfMemoryError 异常。



## 6、运行时常量池（runtime constant pool）

运行时常量池是方法区的一部分，当类加载完成后，会把 **.class**（字节码文件）中的常量池内容存放在运行时常量池中。当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。
